import groovy.json.JsonBuilder
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
def map = [:]
pipeline {
    agent {
        label "master"
    }
    // ! Jenkins Web에서 지정한 tools
    tools {
        // maven 'apache-maven-3.8.6'
        // jdk 'cwchoiit_jdk11'
        maven "jenkins-maven"
    }
    environment {
        // ! Jenkins Web에서 설정한 값
        // TBELL_JIRA_CWCHOI = credentials('tbell-jira-project')
        JIRA_CLOUD_CREDENTIALS = credentials('jira-api-token')
        // ! Jira trigger를 통해 자동으로 받는 값
        JIRA_ISSUE_KEY = "${JIRA_TEST_PLAN_KEY}"
        // TBELL_BACKUP_AUTH = credentials('backup_server_tbell')

        APPIUM_ADDR = "0.0.0.0"
        // APPIUM_PORT = "4723"
        // ! 환경변수 설정 해주면 굳이 써주지 않아도 됨
        // ANDROID_HOME = "C:\\Users\\TB-NTB-223\\AppData\\Local\\Android\\Sdk"
        // ! Jenkins Build URL (Jenkins가 자동으로 만들어주는 변수)
        BUILD_URL = "${BUILD_URL}"
        // ! Jenkins Build ID (Jenkins가 자동으로 만들어주는 변수)
        BUILD_ID = "${BUILD_ID}"
    }
    stages {
        stage("Init") {
            steps {
                script {
                    init(map)
                    println "✅✅✅✅ Init Pipeline ✅✅✅✅"
                    println "Plan issue key: ${JIRA_ISSUE_KEY}"
                    // ! Jenkins Credential을 Username/Password로 지정하면 _USR, _PSW가 변수로 자동 등록
                    // ! 그리고 한가지 유의할 점은 위 JIRA_ISSUE_KEY 와 달리 아래는 작은 따옴표로 {} 없이 사용하고 있는데, 이 이유는 Groovy interpolation으로 민감한 정보는 전달하면 안됨
                    // ! 전달 할 때 host OS에서 arguments value를 그대로 받기 때문에 보안에 취약함 -> Jenkins 공식 문서
                    // map.jira.auth_user = '$TBELL_JIRA_CWCHOI_USR:$TBELL_JIRA_CWCHOI_PSW'
                    // map.jira.auth = "Basic " + "${TBELL_JIRA_CWCHOI_USR}:${TBELL_JIRA_CWCHOI_PSW}".bytes.encodeBase64()
                     map.jira.auth_user = '$JIRA_CLOUD_CREDENTIALS_USR:$JIRA_CLOUD_CREDENTIALS_PSW'
                    map.jira.auth = "Basic " + "${JIRA_CLOUD_CREDENTIALS_USR}:${JIRA_CLOUD_CREDENTIALS_PSW}".bytes.encodeBase64()
                }
            }
        }
        stage("Get test plan") {
            steps {
                script {
                    println "✅✅✅✅ Get test plan ✅✅✅✅"
                    // ! Jira Pipeline steps 라는 plugin 기능 중 jiraGetIssue라는 API를 사용
                    map.issue = jiraGetIssue idOrKey: JIRA_ISSUE_KEY, site: map.jira.site_name
                    // println "issue -> : ${map.issue}"
                    if (map.issue.data.fields.components.name && map.issue.data.fields.components.name[0]) {
                        map.cucumber.feature_name = map.issue.data.fields.components.name[0]
                    }
                    // ! trigger 시킨 이슈타입이 Test Plan 아니라면 에러
                    if (map.issue.data.fields.issuetype.name != map.const.test_plan_issuetype) {
                        jenkinsException(map, "This issue does not matched 'Test Plan/Run' issue type.")
                    }
                }
            }
        }

        stage("Set environments / Get testcases") {
            steps {
                script {
                    println "✅✅✅✅ Set environments / Get testcases ✅✅✅✅"
                    // ! Jira의 custom field 중 Tablet info 라는 select field의 현재 설정된 값을 가져온다.
                    if (map.issue.data.fields[map.const.test_env].value == null) {
                        jenkinsException(map, "Tablet Info field in JIRA 'Test Plan/Run' issue is required.")
                    }
                    def test_env = map.issue.data.fields[map.const.test_env].value[0]

                    println "Test environment (slave) --->" + test_env
                    // ! init method에서 지정해놓은 agents_ref 중 현재 설정된 Tablet info 필드 값과 일치하는 값이 있는지 확인 후 path, slave 설정
                    map.agents_ref.each { key, value ->
                        if (test_env == key) {
                            println "map.current_node1" + map.current_node
                            if (test_env.contains("SM-")) {
                                map.current_node = key.substring(3)
                                println "map.current_node2" + map.current_node
                            } else {
                                map.current_node = key
                            }
                            map.current_path = value
                        }
                    }
                    println "current node: " + map.current_node
                    println "current node's source path: " + map.current_path
                    // ! 위에서 확인한 Tablet info 값이 지정한 환경 중 무엇과도 일치하지 않으면 에러
                    if (map.current_node == null || map.current_path == null) {
                        jenkinsException(map, "JIRA 'Tablet info' field value is invalid. These are the available values: ${map.agents_ref}")
                    }
                    // ! 가져온 Test Plan/Run issue의 Test 대상 필드에 적용된 JQL을 사용하여 get test issues.
                    def jql = map.issue.data.fields[map.const.plan_tests]
                    if (jql.length() <= 0) {
                        jenkinsException(map, "This 'Test Plan/Run' issues has empty value of 'Test 대상' field")
                    }
                    // ! JIRA REST API (JQL로 이슈들 가져오기)
                    def result = getIssuesByJql(map.jira.base_url, map.jira.auth, jql.toString())
                    // ! 가져온 issue가 없으면 에러처리
                    if (result.issues.size() == 0 || result.issues == null) {
                        jenkinsException(map, "This 'Test Plan/Run' issues has no tests")
                    }
                    // ! 이슈들 하나하나의 issueKey:scenario를 map에 저장
                    for (def issue in result.issues) {
                        map.testcases.put(issue.key, issue.fields[map.jira.scenario_field].content[0].content[0].text)
                    }
                }
            }
        }
        stage("Download testcases on slave") {
            // ! agent는 지정한 slave node의 label
            agent {
                label "${map.current_node}"
            }
            steps {
                // ! dir로 특정 path를 지정하면 지정한 slave의 지정한 path에서 작업을 한다는 의미
                dir("${map.current_path}") {
                    script {

                        // def output = bat(encoding: 'UTF-8', script: "adb devices -l | findstr ${map.current_node}", returnStdout: true).trim().readLines().drop(1).join(" ")
                        // sleep 2

                        // udidIndex = output.indexOf("device", 0)
                        // map.const.udid = output.substring(0, udidIndex)

                        // if (map.const.udid == null) {
                        //     jenkinsException(map, "Selected pad not includes SM-583 or SM-T500")
                        // }
                        // println "current UDID:  " + map.const.udid
                        println "✅✅✅✅ Download testcases on slave ✅✅✅✅"
                        println "testcases count --> : ${map.testcases.size()}"
                        if (!fileExists("${map.current_path}\\src\\main\\resources\\app.properties")) {
                            println "no app.properites"
                            map.skipByAppProperties = true
                        }
                        // ! fileExists 라는 Jenkins Pipeline에서 제공하는 method
                        if (fileExists("${map.cucumber.feature_path}")) {
                            // ! 해당 파일/폴더 있다면 지움, 왜냐하면 테스트가 매번 달라질 것이기 때문에 기존 테스트를 위해 만들어진 테스트를 지우기 위함
                            bat script: """ rmdir /s /q "${map.cucumber.feature_path}" """, returnStdout: false
                        }
                        // ! 해당 폴더가 없으면 만듬
                        bat script: """ mkdir "${map.cucumber.feature_path}" """, returnStdout: false

                        // ! map.testcases에 담긴 각 시나리오를 하나의 feature 파일로 변환 하는 과정에서
                        // ! 첫 줄의 Feature Name을 지정


                        // ! JIRA에 올라가 있는 scenario를 가져와서 description으로 해당 JIRA issue key를 붙여준다.
                        // ! issue key를 붙여주는 이유는 해당 시나리오가 JIRA에 어떤 issue와 매핑되는지 알기 위함
                        map.testcases.each { key, value ->

                            def feature = (map.cucumber.feature_name != null) ? "Feature: ${map.cucumber.feature_name}\n\n\n" : "Feature: Default\n\n\n"
                            bat script: """ mkdir "${map.cucumber.feature_path}/${key}" """, returnStdout: false
                            sleep 1
                            def addedDescription = null
                            if (value.contains("\r\n")) {
                                addedDescription = value.replaceFirst("\r\n", ("\r\n" + key + "\n\n"))
                                feature += addedDescription
                                feature += "\n\n"
                            } else {
                                addedDescription = value.replaceFirst("\n", ("\n" + key + "\n\n"))
                                feature += addedDescription
                                feature += "\n\n"
                            }
                            println "key ---> : " + key
                            println "value ---> : " + feature
                            // ! slave의 directory에서 auto.feature라는 파일을 만들고 그 파일에 jira에서 가져온 모든 시나리오를 집어넣음
                            writeFile(file: "./a_features/${key}/${key}.feature", text: feature, encoding: 'UTF-8')
                        }
                    }
                }
            }
        }
        stage("Build") {
            when { expression {!map.skipByAppProperties} }
            agent {
                label "${map.current_node}"
            }
            steps {
                dir("${map.current_path}") {
                     script {
                        println "✅✅✅✅ Build ✅✅✅✅"
                        try {
                            // ! maven build project
                            bat script: 'mvn clean compile -D file.encoding=UTF-8 -D project.build.sourceEncoding=UTF-8 -D project.reporting.outputEncoding=UTF-8'
                        } catch (error) {
                            throwableException(map, error)
                        }
                    }
                }
            }
        }
        stage("Run automation testing") {
            when { expression {!map.skipByAppProperties} }
            // ! agent는 등록한 slave에서만 해당 stage를 실행시킬 수 있다는 의미
            agent{
                label "${map.current_node}"
            }
            steps {
                dir("${map.current_path}") {
                    script {
                        println "✅✅✅✅ Run automation testing ✅✅✅✅"
                        println "source location ==> ${map.current_path}"
                        bat ("echo $ANDROID_HOME")
                        try {
                            // ! Start appium server
                            // ! Real device로 테스트하기 때문에 0.0.0.0 으로 실행시켜야 한다.
                            // ! background로 실행하기 위해 뒤에 &
                            // ! 실행 후 10초정도 대기
                            // * returnStdout: true 옵션을 사용하면 해당 명령어의 실행 결과를 문자열로 반환. 기본값은 false이며, 이 경우 실행 결과를 콘솔 출력으로 표시
                            bat script: "adb devices", returnStdout: true
                            // bat script: "adb kill-server", returnStdout: true
                            // bat script: "adb start-server", returnStdout: true

                            bat "start /B appium --address ${APPIUM_ADDR} --port ${APPIUM_PORT}"
                            sleep 2

                            println "current node: " + map.current_node

                            // *실패한 시나리오를 저장할 맵 선언 추가_24.07.05
                            def failedScenarios = [:]


                            // * 각 테스트 케이스 실행 함수
                            map.testcases.each { key, value ->
                                try {
                                    // ! Run cucumber test command line
                                    // bat encoding: 'UTF-8', script: "mvn exec:java -Dfile.encoding=UTF-8 -Dproject.build.sourceEncoding=UTF-8 -Dproject.reporting.outputEncoding=UTF-8 -Dexec.mainClass=io.cucumber.core.cli.Main -Dexec.args=\"${map.cucumber.feature_path}/${key} --glue ${map.cucumber.glue} --plugin json:./a_features/${key}/${map.cucumber.report_json} --plugin progress:./a_features/${key}/${map.cucumber.running_progress} --publish --plugin pretty --plugin html:./a_features/${key}/${map.cucumber.cucumber_html}\"", returnStdout: false
                                    bat script: "mvn exec:java -Dfile.encoding=UTF-8 -Dproject.build.sourceEncoding=UTF-8 -Dproject.reporting.outputEncoding=UTF-8 -Dexec.mainClass=io.cucumber.core.cli.Main -Dexec.args=\"${map.cucumber.feature_path}/${key} --glue ${map.cucumber.glue} --plugin json:./a_features/${key}/${map.cucumber.report_json} --plugin progress:./a_features/${key}/${map.cucumber.running_progress} --publish --plugin pretty --plugin html:./a_features/${key}/${map.cucumber.cucumber_html}\"", returnStdout: false
                                } catch (error) {
                                    // println error
                                    // 처음 실행에서 실패한 시나리오 저장
                                    failedScenarios[key] = value
                                    println "Initial run failed for scenario: ${key}"
                                }
                            }    

                            // *실패한 시나리오 수 출력
                            println "Number of failed scenarios: ${failedScenarios.size()}"

                            // *실패한 시나리오가 지정한 갯수 미만일 경우 재실행
                            if (failedScenarios.size() < 30) {

                                // 성능 측정 시작
                                println "✅✅✅✅ 기기 성능 측정 시작 ✅✅✅✅"
            
                                
                                    // 현재 노드 출력  
                                    println "current node: ${map.current_node}"  

                                    // 기기별 app.properties 경로 설정  
                                    def appPropertiesPath = "${map.current_path}\\src\\main\\resources\\app.properties"  
                                    echo "Using app.properties from: ${appPropertiesPath}"  

                                    // app.properties 파일 읽기  
                                    def propsContent = readFile(appPropertiesPath)  
                                    def props = [:]  

                                    // content를 줄 단위로 나누고 키-값 쌍으로 파싱  
                                    propsContent.split('\n').each { line ->  
                                        if (line && !line.startsWith('#')) { // 주석 제거  
                                            def splitLine = line.split('=')  
                                            if (splitLine.size() == 2) {  
                                                props[splitLine[0].trim()] = splitLine[1].trim()  
                                            }  
                                        }  
                                    }  

                                    // deviceName과 udid 가져오기  
                                    def deviceName = props['deviceName']  
                                    def udid = props['udid']  
                                    def packageName = getPackageName(udid)

                                    echo "Device Name: ${deviceName}"  
                                    echo "UDID: ${udid}"
                                    echo "Package Name: ${packageName}"

                                try {

                                    // def scriptContent = """
                                    // @echo off
                                    // echo [%date% %time%] GPU 정보: > gpu_info_${deviceName}.txt
                                    // adb -s ${udid} shell dumpsys gfxinfo ${packageName} | findstr /C:"Total frames" /C:"Janky frames" /C:"Average time" /C:"FPS" >> gpu_info_${deviceName}.txt
                                    // """

                                    def scriptContent = """
                                    @echo off

                                    REM Jenkins에서 제공한 기기 이름을 환경 변수로 사용
                                    set DEVICE_NAME=${deviceName}
                                    set FORMATTED_DEVICE_NAME=%DEVICE_NAME: =_%

                                    REM 생성할 파일 이름에 언더스코어가 포함된 기기 이름을 사용
                                    set OUTPUT_FILE=gpu_info_%FORMATTED_DEVICE_NAME%.txt

                                    REM 이전 GPU 정보 파일 삭제
                                    if exist %OUTPUT_FILE% (  
                                        del %OUTPUT_FILE%  
                                    )   

                                    echo [%date% %time%] GPU 정보: > %OUTPUT_FILE%
                                    adb -s ${udid} shell dumpsys gfxinfo >> %OUTPUT_FILE%
                                    """

                                    writeFile file: 'gpu_monitor.bat', text: scriptContent
                                    
                                    // GPU 정보 수집 실행
                                    bat script: 'gpu_monitor.bat', returnStatus: true

                                    echo "GPU 정보 수집 시작"

                                    // performance_monitor_vol2.cmd 파일을 백그라운드에서 실행하고 PID 저장
                                    // bat(script: """
                                    //     start /B cmd /c "${map.current_path}\\src\\main\\resources\\performance_monitor_vol2.cmd" "${deviceName}" ${udid}
                                    //     for /f "tokens=2" %%a in ('tasklist /fi "imagename eq cmd.exe" /fo list /v ^| find /i "performance_monitor_vol2.cmd"') do @echo %%a > pid.txt
                                    // """)
                                    // performanceMonitorPID = readFile('pid.txt').trim()
                                                            
                                    println "✅✅✅✅ 재시작 failed scenarios ✅✅✅✅"
                                    failedScenarios.each { key, value ->
                                        try {
                                            // 해당 시나리오 재실행
                                            bat script: "mvn exec:java -Dfile.encoding=UTF-8 -Dproject.build.sourceEncoding=UTF-8 -Dproject.reporting.outputEncoding=UTF-8 -Dexec.mainClass=io.cucumber.core.cli.Main -Dexec.args=\"${map.cucumber.feature_path}/${key} --glue ${map.cucumber.glue} --plugin json:./a_features/${key}/${map.cucumber.report_json} --plugin progress:./a_features/${key}/${map.cucumber.running_progress} --publish --plugin pretty --plugin html:./a_features/${key}/${map.cucumber.cucumber_html}\"", returnStdout: false
                                        } catch (error) {
                                            println "Retry failed for scenario: ${key}"
                                        }

                                    } 

                                    // 성능 로그 파일을 아티팩트로 저장
                                        // def logFileName = "gpu_info_${props['deviceName']}_${new Date().format('yyyyMMdd_HHmmss')}.txt"
                                        // archiveArtifacts artifacts: logFileName, fingerprint: true, allowEmptyArchive: true
                                        
                                    try {
                                        // GPU 모니터링 종료
                                        def killResult = bat(script: """
                                            adb -s ${udid} shell pkill -f "dumpsys gfxinfo"
                                            echo GPU 모니터링 프로세스가 종료되었습니다.
                                        """, returnStatus: true)

                                        // 잠시 대기 (프로세스가 완전히 종료되도록)
                                        sleep 5

                                        if (killResult != 0) {
                                            echo "경고: GPU 모니터링 프로세스 종료 중 문제가 발생했을 수 있습니다."
                                        }

                                        // 성능 로그 파일을 아티팩트로 저장
                                        // 성능 로그 파일 이름 생성
                                        def logFileName = "gpu_info_${deviceName.replaceAll(" ", "_")}.txt"
                                        def logFilePath = "${map.current_path}\\${logFileName}"
                                        
                                        echo "로그 파일 경로: ${logFilePath}"
                                        bat "adb -s ${udid} shell dumpsys gfxinfo > ${logFileName}"
                                        // bat "adb -s ${udid} shell dumpsys gfxinfo ${packageName} > ${logFileName}"

                                        // 빌드 아티팩트에 로그 파일 저장
                                        archiveArtifacts artifacts: "${logFileName}", fingerprint: true , allowEmptyArchive: true

                                        echo "성능 로그 파일 '${logFileName}'을 아티팩트로 저장했습니다."
                                        
                                        

                                    } catch (Exception e) {
                                        echo "성능 측정 중 오류 발생: ${e.message}"
                                        // getStackTrace() 대신 toString() 사용
                                        echo "오류 상세 정보: ${e.toString()}"
                                    }
                                }catch (performanceError) {
                                        println "성능 측정 중 오류 발생: ${performanceError.message}"
                                }
                            }
                             else {
                                // *실패한 시나리오가 지정한 갯수 이상인 경우 재실행을 건너뜀
                                println "Skipping retry as number of failed scenarios is 30 or more."
                            }

                            // ? sh(shell script) -> bat(windows에서만)
                            OUTPUT = bat script: "netstat -aon | findstr 0.0.0.0:${APPIUM_PORT} | findstr LISTENING", returnStdout: true
                            println OUTPUT
                            println OUTPUT.substring(OUTPUT.length() - 9)
                            pID = OUTPUT.substring(OUTPUT.length() - 9)
                            sleep 1

                            KILL_OUTPUT = bat script: "taskkill /F /IM ${pID}", returnStdout: true
                            echo KILL_OUTPUT
                        } catch(error) {
                            throwableException(map, error)
                        }
                    }
                }
            }
        }
        stage("Analysis test result") {
            when { expression {!map.skipByAppProperties} }
            agent { label "${map.current_node}" }
            steps {
                dir("${map.current_path}") {
                    script {
                        println "✅✅✅✅ Analysis test result ✅✅✅✅"

                        try {
                            def isPassed = true

                            map.testcases.each { key, value ->
                                // ! 테스트 후 생성된 cucumber.json 파일을 가져온다.
                                map.cucumber.result_json = readFile file: "./a_features/${key}/${map.cucumber.report_json}"
                                def folder = "${key}"
                                println "key_________________>${key}"
                                println "value_________________>${value}"
                                println "folder___________>${folder}"
                                // bat encoding:"UTF-8", script: """copy ./defect_screenshots/${scenarioName}.png ./a_features/${folder}/error_screenShot.png""", returnStdout: false
                                // ! 가져온 cucumber.json 파일을 parsing
                                def results = new JsonSlurper().parseText(map.cucumber.result_json as String)
                                def clearResult = results[0].elements
                                def currentIssue = null
                                def scenarioName = null
                                def errorreason = ""
                                for (def result in clearResult) {
                                    // ! description에는 반드시 해당 jira issue key값이 들어있어야 한다. 상위 stage에서 이 부분을 처리해줬음
                                    if (result.description == "") {
                                        jenkinsException(map, "Scenario description (Issue key) required.")
                                    }
                                    currentIssue = result.description.trim()
                                    // ! 테스트 Scenario의 name
                                    scenarioName = result.name.trim().replaceAll(" ", "_")
                                    println "defect screenshot name --> ${scenarioName}"

                                    // ! 테스트 Scenario의 before, after step의 result
                                    def before = result.before[0].result
                                    def after = result.after[0].result
                                    if (!before.status.contains("passed")) {
                                        map.cucumber.error_message = before.error_message
                                        isPassed = false
                                        // ! create defect issue
                                        def res = createIssue(map.jira.base_url, map.jira.auth, createBugPayload(map.jira.project_key,
                                                "Defect of test '${currentIssue}'",
                                                errorreason,
                                                map.cucumber.error_message,
                                                map.jira.defect_issuetype)
                                        )


                                        // ! 추후 stage에서 screenshot을 attach할 때 필요한 정보들
                                        map.cucumber.defect_info.put(res.key, scenarioName)



                                        // ! Plan/Run linked with Bug
                                        linkIssue(map.jira.base_url, map.jira.auth, createLinkPayload(JIRA_ISSUE_KEY, res.key, map.jira.defect_link))
                                        // ! Bug linked with Test case
                                        linkIssue(map.jira.base_url, map.jira.auth, createLinkPayload(res.key, currentIssue, map.jira.tests_link))
                                        // ! continue 처리를 하는 이유는 passed가 아닌 이후부터는 모든 step이 skipped 상태이기 때문에 문제가 발생한 스텝에서의 에러를 defect로 생성하고 다음 scenario로 넘어가면 됨
                                        continue
                                    }
                                    if (!after.status.contains("passed")) {
                                        map.cucumber.error_message = after.error_message
                                        isPassed = false

                                        errorreason = errordescrit(after.error_message)
                                        def res = createIssue(map.jira.base_url, map.jira.auth, createBugPayload(map.jira.project_key,
                                                "Defect of test '${currentIssue}'",
                                                errorreason,
                                                map.cucumber.error_message,
                                                map.jira.defect_issuetype)
                                        )

                                        // ! Plan/Run linked with Bug
                                        linkIssue(map.jira.base_url, map.jira.auth, createLinkPayload(JIRA_ISSUE_KEY, res.key, map.jira.defect_link))
                                        // ! Bug linked with Test case
                                        linkIssue(map.jira.base_url, map.jira.auth, createLinkPayload(res.key, currentIssue, map.jira.tests_link))
                                        continue
                                    }

                                    for (def step in result.steps) {
                                        def eachStep = step.result
                                        if (!eachStep.status.contains("passed")) {
                                            map.cucumber.error_message = eachStep.error_message
                                            def uiElement = extractUiElement(map.cucumber.error_message)

                                            errorreason = errordescrit(map.cucumber.error_message, uiElement)
                                       
                                            if (map.cucumber.error_message == null || map.cucumber.error_message == "") {
                                                // ! undefined은 error_message가 없어서 직접 처리해줘야 함. undefined은 해당 step이 implement되지 않았을 때 발생함
                                                if (eachStep.status.contains("undefined")) {
                                                    isPassed = false
                                                    def res = createIssue(map.jira.base_url, map.jira.auth, createBugPayload(map.jira.project_key,
                                                            "Defect of test '${currentIssue}'",
                                                            errorreason,
                                                            "step '${step.name}'의 step definition이 정의되지 않았습니다.", map.jira.defect_issuetype)
                                                    )
                                                    // ! Plan/Run linked with Bug
                                                    linkIssue(map.jira.base_url, map.jira.auth, createLinkPayload(JIRA_ISSUE_KEY, res.key, map.jira.defect_link))
                                                    // ! Bug linked with Test case
                                                    linkIssue(map.jira.base_url, map.jira.auth, createLinkPayload(res.key, currentIssue, map.jira.tests_link))
                                                    // ! 역시 마찬가지로 passed가 아닌 무언가 (undefined, failed) 생긴 이후 step은 다 skipped임 그래서 이 for문을 빠져나가면 됨

                                                    break
                                                } else {
                                                    // ! error_message가 없고 undefined가 아니면 skipped인 경우밖에 없음 근데 skipped인 경우가 loop에서 나오면 안됨 (skipped가 나오기전에 빠져나오는 로직을 실행하기 때문에)
                                                    jenkinsException(map, "error message is empty")
                                                }
                                            }
                                            isPassed = false
                                            println currentIssue
                                            println map.cucumber.error_message
                                            println map.jira.defect_issuetype
                                            println errorreason

                                            def res = createIssue(map.jira.base_url, map.jira.auth, createBugPayload(map.jira.project_key,
                                                    "Defect of test '${currentIssue}'",
                                                    errorreason,
                                                    map.cucumber.error_message,
                                                    map.jira.defect_issuetype)
                                            )


                                            // ! 추후 stage에서 screenshot을 attach할 때 필요한 정보들
                                            map.cucumber.defect_info.put(res.key, scenarioName)
                                            //bat encoding:"UTF-8", script: """copy .\\defect_screenshots\\${scenarioName}.png .\\a_features\\${folder}\\errorscreenshot.png""", returnStdout: false


                                            // ! Plan/Run linked with Bug
                                            linkIssue(map.jira.base_url, map.jira.auth, createLinkPayload(JIRA_ISSUE_KEY, res.key, map.jira.defect_link))
                                            // ! Bug linked with Test case
                                            linkIssue(map.jira.base_url, map.jira.auth, createLinkPayload(res.key, currentIssue, map.jira.tests_link))
                                            break
                                        }
                                    }
                                }
                            }

                            if (isPassed) {
                                // ! 이 statement가 실행되는 경우는 모든 step이 다 passed 될 경우임 그래서 test plan/run issue를 finish 상태로 변경
                                transitionIssue(map.jira.base_url, map.jira.auth, transitionPayload(map.jira.success_transition), JIRA_ISSUE_KEY)
                            } else {
                                // ! 이 statement가 실행되는 경우는 모든 시나리오 중 하나라도 passed가 이루어지지 않은 시나리오가 있다면 실행됨 test plan/run issue를 test fail 상태로 변경
                                transitionIssue(map.jira.base_url, map.jira.auth, transitionPayload(map.jira.fail_transition), JIRA_ISSUE_KEY)
                            }
                        } catch (error) {
                            throwableException(map, error)
                        }
                    }
                }
            }
        }
        stage("Attached defect screenshots") {
            when { expression {!map.skipByAppProperties} }
            agent { label "${map.current_node}" }
            steps {
                dir("${map.current_path}") {
                    script {
                        println "✅✅✅✅ Attached defect screenshots or bypass ✅✅✅✅"
                        if (map.cucumber.defect_info.size() > 0) {
                            // ! cURL로 각 defect issue에 맞는 defect screenshot을 업로드한다.
                            map.cucumber.defect_info.each { key, value ->
                                try {
                                    bat encoding:"UTF-8", script: """curl --insecure -D- -u ${JIRA_CLOUD_CREDENTIALS_USR}:${JIRA_CLOUD_CREDENTIALS_PSW} -X POST -H "X-Atlassian-Token: no-check" -F "file=@./defect_screenshots/${value}.png;filename=errorscreenshot.png" ${map.jira.base_url}/rest/api/3/issue/${key}/attachments""", returnStdout:false
                                    // bat encoding:"UTF-8", script: """curl --insecure -D- -u ${JIRA_CLOUD_CREDENTIALS_USR}:${JIRA_CLOUD_CREDENTIALS_PSW} -X POST -H "X-Atlassian-Token: no-check" -F "file=@C:\\Users\\TB-NTB-223\\CICD\\SM-T500\\workspace\\WJ_Test\\defect_screenshots\\${value}.png;filename=errorscreenshot.png" ${map.jira.base_url}/rest/api/3/issue/${key}/attachments""", returnStdout:false
                                } catch (error) {


                                }
                            }
                        }
                    }
                }
            }
        }
        stage("Generate cucumber html reports") {
            when { expression {!map.skipByAppProperties} }
            agent { label "${map.current_node}" }
            steps {
                dir("${map.current_path}") {
                    script {
                        println "✅✅✅✅ Generate cucumber html reports ✅✅✅✅"
                        // ! Jenkins plugin -> Cucumber reports를 설치한 상태에서 실행해야 한다.
                        // ! buildStatus가 UNSTABLE이 의미하는 건 테스트 실행 후 하나라도 fail이 생기면 build의 status가 unstable 상태로 끝남, 만약 모두 패스면 success로 끝남
                        // ! 이렇게 하는 이유는 테스트가 fail이 나는 scenario가 있다고해서 build가 fail이라고 볼 순 없고 그렇다고 success라고 보기도 애매하기 때문에 상황에 맞춰서 build status를 표시하게 하기 위함
                        cucumber buildStatus: 'UNSTABLE',
                                reportTitle: 'My report',
                                fileIncludePattern: '**/*.json',
                                trendsLimit: 10,
                                classifications: [
                                        [
                                                'key': 'Browser',
                                                'value': 'Chrome'
                                        ]
                                ]

                        def payload = [
                                "fields": [
                                        "${map.jira.test_result_link}": "${BUILD_URL}${map.cucumber.report_link}"
                                ]
                        ]
                        payload = JsonOutput.toJson(payload)

                        // ! test plan/run 이슈의 Test Result Link 필드에 cucumber report url을 fetch
                        updateIssue(map.jira.base_url, map.jira.auth, payload, JIRA_ISSUE_KEY)

                        // *댓글 내용 생성
                        def commentBody = "Cucumber HTML report URL: ${BUILD_URL}${map.cucumber.report_link}"

                        // *댓글 JSON 페이로드 생성
                        def commentPayload = createCommentPayload(commentBody)

                        // *Jira API에 댓글 추가
                        def response = createComment(map.jira.base_url, map.jira.auth, commentPayload, JIRA_ISSUE_KEY)
                        // echo "Comment posted: ${response}"


                        if (map.cucumber.defect_info.size() > 0) {
                            // ! cURL로 각 defect issue에 맞는 defect screenshot을 업로드한다.
                            map.cucumber.defect_info.each { key, value ->
                                map.testcases.each { tcKey, tcValue ->
                                    if (tcValue.replaceAll(" ", "_").contains(value)) {
                                        bat encoding:"UTF-8", script: """curl --insecure -D- -u ${JIRA_CLOUD_CREDENTIALS_USR}:${JIRA_CLOUD_CREDENTIALS_PSW} -X POST -H "X-Atlassian-Token: no-check" -F "file=@./a_features/${tcKey}/${map.cucumber.cucumber_html}" ${map.jira.base_url}/rest/api/3/issue/${key}/attachments""", returnStdout:false

                                    }
                                }
                            }
                        }

                    }
                }
            }
        }
    }
    post {
        always {
            script {
                if (map.skipByAppProperties) {
                    println "⚠️⚠️⚠️ app.properties file missing (in src/main/resources folder) ⚠️⚠️⚠️"
                    transitionIssue(map.jira.base_url, map.jira.auth, transitionPayload(map.jira.fail_transition), JIRA_ISSUE_KEY)
                } else {
                    // ! 아래는 jenkins build가 어떻게 끝나든 무조건 test plan/run issue의 'Job Run No' field의 값에 jenkins build id를 넣어줌
                    def payload = [
                            "fields": [
                                    "${map.jira.job_link}": "#${BUILD_ID}"
                            ]
                    ]
                    payload = JsonOutput.toJson(payload)
                    updateIssue(map.jira.base_url, map.jira.auth, payload, JIRA_ISSUE_KEY)
                }
            }
        }
        failure {
            script {
                try {
                    // ! pipeline을 실행하면서 에러가 나서 fail로 떨어지면 무조건 jira plan/run issue의 status를 fail로 처리
                    transitionIssue(map.jira.base_url, map.jira.auth, transitionPayload(map.jira.fail_transition), JIRA_ISSUE_KEY)
                    // ! try catch로 감싼 이유는 이미 status가 fail일 수 있기 때문에 이미 fail인 상태면 처리
                } catch (RuntimeException) {}
            }
        }
    }
}
// * methods * //
// ? Custom exception method
def jenkinsException(java.util.Map map, String error) {
    map.exceptionMsg = error
    throw new RuntimeException("❌ " + error + " ❌")
}
// ? Catching exception
def throwableException(java.util.Map map, Exception e) {
    map.exceptionMsg = e.toString()
    throw e as java.lang.Throwable
}
// ? init map for variables and environments
def init(def map) {
    map.issue = null
    map.skipByAppProperties = false
    map.current_node = null
    map.testcases = [:]
    map.current_path = null
    map.agents_ref = [
        // * 노트북별로 path 써주기

        "M1 Pad":"C:\\Users\\TB-NTB-024\\CICD\\M101\\workspace\\WJ_Test",
        "M2 Pad":"C:\\Users\\TB-NTB-024\\CICD\\M102\\workspace\\WJ_Test",
        "T500":"C:\\Users\\TB-NTB-223\\CICD\\SM-T500\\workspace\\WJ_Test",
        "T583":"C:\\Users\\TB-NTB-223\\CICD\\SM-T583\\workspace\\WJ_Test",
        "X200":"C:\\Users\\TB-NTB-223\\CICD\\X200\\workspace\\WJ_Test"
    ]
    map.git = [:]
    map.git.branch = "master"
    // map.git.url = "git://22.4.20.13/TBELL_PROJECT.git"
    map.git.url = "https://github.com/withsjb/wonjin_solo_test.git"
    map.jira = [:]
    // ! Jira Steps Plugin을 위해 Configure System에서 설정한 값
    // map.jira.site_name = "TBELL_PROJECT"
    map.jira.site_name = "JIRA_CLOUD_JINBIN"
    map.jira.base_url = "https://withsjb1.atlassian.net"
    map.jira.project_key = "WON"
    map.jira.defect_issuetype = "Defect"
    // ! scenario field on tests issue
    map.jira.scenario_field = "customfield_10058"
    // ! transition id for test start -> test fail
    map.jira.fail_transition = "21"
    // ! transition id for test start -> finish
    map.jira.success_transition = "31"
    // ! plan/run - bug link name
    map.jira.defect_link = "Defect"
    // ! bug - test link name
    map.jira.tests_link = "Tests"
    // ! Job Run No. field
    map.jira.job_link = "customfield_10062"
    // ! Test Result Link field
    map.jira.test_result_link = "customfield_10063"


    map.const = [:]
    // ! Test plan/Run의 'Test 대상' field 
    map.const.plan_tests = "customfield_10059"
    // ! Test Plan/Run의 'Tablet Info' field (Multi Select field -> array)
    map.const.test_env = "customfield_10061"
    map.const.test_plan_issuetype = "Test Plan/Run"
    map.const.udid = null

    map.cucumber = [:]
    // ! Test Plan/Run issue의 컴포넌트에서 값이 있다면 이 feature_name에 지정할 것
    map.cucumber.feature_name = null
    // ! feature파일의 생성 경로
    map.cucumber.feature_path = "a_features"
    map.cucumber.defect_screenshot_path = "defect_screenshots"
    // ! defect가 생길경우 해당 defect issue key와 해당 defect를 생성시킨 testcase의 scenario명을 저장하기 위함
    map.cucumber.defect_info = [:]
    map.cucumber.scenario_name = null
    map.cucumber.glue = "stepdefinitions"
    map.cucumber.report_json = "cucumber.json"
    map.cucumber.running_progress = "cucumber_progress.html"
    map.cucumber.cucumber_html = "cucumber_report.html"
    map.cucumber.log_path = "features_log"
    map.cucumber.log_suffix = ".feature.log"
    map.cucumber.result_json = null
    map.cucumber.error_message = null
    // ! Cucumber reports 라는 Jenkins plugin을 설치하면 cucumber test를 build 시킬 때 아래와 같은 html 파일을 job number 별로 나눠서 떨어뜨려줌
    map.cucumber.report_link = "cucumber-html-reports_fb242bb7-17b2-346f-b0a4-d7a3b25b65b4/overview-features.html"
}
def createBugPayload(String projectKey, String summary, String errre, String logdetail, String issuetype) {
    // 로그 및 에러 메시지 처리
    String log = logdetail
    
    // 실패 원인 텍스트
    String errordetail =  errre

    // 로그 내용
    String description =  log 
    
    def payload = [
        "fields": [
            "project": ["key": "${projectKey}"],
            "summary": "${summary}",
            "description": [
                "type": "doc",
                "version": 1,
                "content": [
                    [
                        "type": "paragraph",
                        "content": [
                            [
                                "type": "text",
                                "text": "[테스트 실패 원인]",
                                "marks": [
                                    [
                                        "type": "strong"
                                    ],
                                    [
                                        "type": "textColor",
                                        "attrs": [
                                            "color": "#FF0000"
                                        ]
                                    ]
                                ]
                            ],
                            [
                                "type": "hardBreak"
                            ],
                            [
                                "type": "text",
                                "text": "${errordetail}"
                            ],
                            [
                                "type": "hardBreak"
                            ],
                            [
                                "type": "text",
                                "text": "[테스트 실패 로그]",
                                "marks": [
                                    [
                                        "type": "strong"
                                    ],
                                    [
                                        "type": "textColor",
                                        "attrs": [
                                            "color": "#FF0000"
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ],
                    [
                        "type": "codeBlock",
                        "attrs": [
                            "language": "java"
                        ],
                        "content": [
                            [
                                "type": "text",
                                "text": "${description}"
                            ]
                        ]
                    ]
                ]
            ],
            "assignee": [
                // ! jira 로그인별 ID 값 변경 필요
                "id": "63fd816e9cba7ca028770bb2"
            ],
            "issuetype": ["name": "${issuetype}"],
            "priority": ["name": "Major"]
        ]
    ]
    return JsonOutput.toJson(payload)
}
// JIRA API
def createIssue(String baseUrl, String auth, String payload) {
    def url = "${baseUrl}/rest/api/3/issue"
    def conn = new URL(url).openConnection()
    conn.setRequestMethod("POST")
    conn.setDoOutput(true)
    conn.setRequestProperty("Content-Type", "application/json")
    conn.addRequestProperty("Authorization", auth)
    if (payload) {
        conn.getOutputStream().write(payload.getBytes("UTF-8"))
    }
    def responseCode = conn.getResponseCode()
    println "createIssue response --> : ${responseCode}"
    if (responseCode != 200 && responseCode != 201 && responseCode != 204) {
        throw new RuntimeException("Error - httpCode : ${responseCode}")
    }
    def response = conn.getInputStream().getText()
    def result = new JsonSlurper().parseText(response)
    println "result --> : ${result}"
    return result
}
def createLinkPayload(String planIssueKey, String createdDefectKey, String linkType) {
    def payload = [
            "type": ["name": "${linkType}"],
            "inwardIssue": ["key": "${planIssueKey}"],
            "outwardIssue": ["key": "${createdDefectKey}"]
    ]
    return JsonOutput.toJson(payload)
}
// JIRA API
def linkIssue(String baseUrl, String auth, String payload) {
    def url = "${baseUrl}/rest/api/3/issueLink"
    def conn = new URL(url).openConnection()
    conn.setRequestMethod("POST")
    conn.setDoOutput(true)
    conn.setRequestProperty("Content-Type", "application/json")
    conn.addRequestProperty("Authorization", auth)
    if (payload) {
        conn.getOutputStream().write(payload.getBytes("UTF-8"))
    }
    def responseCode = conn.getResponseCode()
    println "linkIssue response --> : ${responseCode}"
    if (responseCode != 201) {
        // throw new RuntimeException("Error - httpCode : ${responseCode}")
        throw new RuntimeException("Link Jira Issue Error -> " + conn.getErrorStream() +" response: "+ conn.getResponseMessage() +" httpCode: "+ responseCode )

    }
}
def getIssuesByJql(String baseUrl, String auth, String jql) {
    def encodedJql = java.net.URLEncoder.encode(jql, "UTF-8")
    println "replace jql --> : ${encodedJql}"
    def url = "${baseUrl}/rest/api/3/search?jql=${encodedJql}&maxResults=500"
    println "url ---> ${url}"
    def conn = new URL(url).openConnection()
    conn.setRequestMethod("GET")
    conn.setDoOutput(true)
    conn.setRequestProperty("Content-Type", "application/json;charset=UTF-8")
    conn.addRequestProperty("Authorization", auth)

    def responseCode = conn.getResponseCode()
    def response = conn.getInputStream().getText()
    def result = new JsonSlurper().parseText(response)
    if (responseCode != 200) {
        // throw new RuntimeException("Error - httpCode : ${responseCode}")
        throw new RuntimeException("Get Jira Issue Error -> " + conn.getErrorStream() +" response: "+ conn.getResponseMessage() +" httpCode: "+ responseCode )

    }
    return result
}
def transitionPayload(String transition) {
    def payload = [
            "transition": [
                    "id": "${transition}"
            ]
    ]
    return JsonOutput.toJson(payload)
}
def transitionIssue(String baseUrl, String auth, String payload, String issueKey) {
    def url = "${baseUrl}/rest/api/2/issue/${issueKey}/transitions"
    def conn = new URL(url).openConnection()
    conn.setRequestMethod("POST")
    conn.setDoOutput(true)
    conn.setRequestProperty("Content-Type", "application/json")
    conn.addRequestProperty("Authorization", auth)
    conn.getOutputStream().write(payload.getBytes("UTF-8"))
    def responseCode = conn.getResponseCode()
    println "transitionIssue response --> : ${responseCode}"
    if (responseCode != 204) {
        // throw new RuntimeException("Error - httpCode : ${responseCode}")
        throw new RuntimeException("Transition Jira Issue Error -> " + conn.getErrorStream() +" response: "+ conn.getResponseMessage() +" httpCode: "+ responseCode )

    }
}
def updateIssue(String baseUrl, String auth, String payload, String issueKey) {
    def url = "${baseUrl}/rest/api/2/issue/${issueKey}"
    def conn = new URL(url).openConnection()
    conn.setRequestMethod("PUT")
    conn.setDoOutput(true)
    conn.setRequestProperty("Content-Type", "application/json")
    conn.addRequestProperty("Authorization", auth)
    conn.getOutputStream().write(payload.getBytes("UTF-8"))
    def responseCode = conn.getResponseCode()
    println "updateIssue response ---> ${responseCode}"
    if (responseCode != 204) {
        // throw new RuntimeException("Error - httpCode : ${responseCode}")
        throw new RuntimeException("Update Jira Issue Error -> " + conn.getErrorStream() +" response: "+ conn.getResponseMessage() +" httpCode: "+ responseCode )

    }
}

def createCommentPayload(String commentBody) {
    def payload = [
        "body": commentBody
    ]
    return JsonOutput.toJson(payload)
}

def createComment(String baseUrl, String auth, String payload, String issueKey) {
    def url = "${baseUrl}/rest/api/2/issue/${issueKey}/comment"
    def conn = new URL(url).openConnection()
    conn.setRequestMethod("POST")
    conn.setDoOutput(true)
    conn.setRequestProperty("Content-Type", "application/json")
    conn.setRequestProperty("Authorization", auth) // Basic Auth
    conn.getOutputStream().write(payload.getBytes("UTF-8"))

    def responseCode = conn.getResponseCode()
    def response
    if (responseCode == 400) {
        response = conn.getErrorStream().getText() // 오류 스트림에서 응답 읽기
    } else {
        response = conn.getInputStream().getText() // 정상 스트림에서 응답 읽기
    }
    println "createComment response --> : ${responseCode}"
    if (responseCode != 201) {
        throw new RuntimeException("Create Comment Error -> Response: ${response}, httpCode: ${responseCode}")
    }
    return response
}

def getPackageName(udid) {
    def packageName = ''
    try {
        // 현재 포그라운드 앱의 패키지 이름 가져오기
        packageName = bat(script: "adb -s ${udid} shell dumpsys window | findstr mCurrentFocus", returnStdout: true).trim()
        // 결과에서 패키지 이름만 추출
        packageName = packageName.split('/')[-1].split('}')[0]
    } catch (Exception e) {
        println "패키지 이름을 가져오는 중 오류 발생: ${e.message}"
        // 기본 패키지 이름 설정
        packageName = 'com.default.package'
    }
    return packageName
}


def errordescrit(String errorMessage, String uiElement){
    if (errorMessage != null && !errorMessage.trim().isEmpty()) {
        try {
            throw new RuntimeException(errorMessage)
        } catch (RuntimeException t) {
            def logBuffer = new StringBuilder()
            for (StackTraceElement element : t.getStackTrace()) {
                logBuffer.append(element.toString()).append("\n")
            }
            
            def errorStackTrace = logBuffer.toString()
            println "Stack trace logged: \n${errorStackTrace}"
            println "오류난 ui: \n${uiElement}"

            int time = 30;
            
            String anotherUi = "팝업 창"

            String errorreason = geterrorReason(t, uiElement, anotherUi, time)
            println "Generated error reason: ${errorreason}"

            return errorreason
        }
    }
    return "오류 메시지가 제공되지 않았습니다."
}


def geterrorReason(Throwable t, String ui, String anotherUi, int time) {
    String errorReason

    switch (t.getClass().getSimpleName()) {
            case "NoSuchElementException":
                errorReason = String.format("UI 요소 ${ui}를 찾지 못했습니다.")
                break
            case "ElementNotVisibleException":
                errorReason = String.format("UI 요소 ${ui}가 화면에 보이지 않습니다.")
                break
            case "StaleElementReferenceException":
                errorReason = String.format("UI 요소 ${ui}가 새로 로드되거나 화면에서 사라졌습니다.")
                break
            case "TimeoutException":
                errorReason = String.format("UI 요소 ${ui}가 ${time}초 동안 화면에 나타나지 않았습니다.")
                break
            case "NoSuchWindowException":
                errorReason = "작업 중인 창을 찾을 수 없습니다."
                break
            case "WebDriverException":
                errorReason = "WebDriver가 제대로 연결되지 않았거나 실행되지 않았습니다. 경로를 확인하세요."
                break
            case "SessionNotCreatedException":
                errorReason = "WebDriver 세션을 시작할 수 없습니다. 드라이버 버전과 브라우저 버전을 확인하세요."
                break
            case "ElementClickInterceptedException":
                errorReason = String.format("클릭하려는 요소 ${ui}가 다른 요소 ${anotherUi}에 의해 가려져 있습니다.")
                break
            case "HttpRequestException":
                errorReason = "네트워크 요청이 실패했습니다. 인터넷 및 와이파이를 확인하세요!"
                break
            case "SocketTimeoutException":
                errorReason = "네트워크가 지정된 시간 동안 응답을 받지 못했습니다. 인터넷 및 와이파이를 확인하세요!"
                break
            case "RuntimeException":
                errorReason = "테스트 진행 시간동안 ${ui}가 나타나지 않았습니다."
                break
            default:
                errorReason = "알 수 없는 오류가 발생했습니다. 오류 메시지: " + t.getMessage()
                break
        }

        return errorReason

}


def extractUiElement(String errorMessage) {
    def idPattern = ~/By\.id:\s*([\w:.]+)/    // By.id 추출 정규식
    def xpathPattern = ~/By\.xpath:\s*([^\s]+)/ // By.xpath 추출 정규식

    def matcher = errorMessage =~ idPattern
    if (matcher.find()) {
        return matcher.group(1)  // 추출된 ID 값 반환
    }

    matcher = errorMessage =~ xpathPattern
    if (matcher.find()) {
        return matcher.group(1)  // 추출된 XPath 값 반환
    }

    return "알 수 없는 UI 요소"
}